# TCP最近一直在看一些网络基础相关的知识，以便解决在工作中遇到的关于网络传输方面的问题。因此觉得有必要对最近学习的网络协议做一个简单的总结。
### 网络通信原理
1.  互联网的本质就是一系列的网络协议
- 一台计算机有了操作系统，然后装上软件你就可以正常使用了，但是这种情况下你只能够自己使用，是没有交朋友的能力的，因为你跟别的计算机之间无法沟通。

![](https://user-gold-cdn.xitu.io/2018/2/22/161bb27eecf98410?w=544&h=362&f=jpeg&s=47663)

- 为了提供计算机沟通的能力，有了internet

![](https://user-gold-cdn.xitu.io/2018/2/22/161bb2994db66c9c?w=429&h=270&f=jpeg&s=29986)

- internet实际上就是一系列统一的标准，这些标准称之为互联网协议，其功能就是定义计算机如何接入internet，以及接入internet的计算机通信的标准。
2.  osi七层协议
互联网协议按照功能不同分为osi七层或tcp/ip五层或tcp/ip四层，值得说明的是这些层是逻辑上认定的层次，并不是实际存在的。

![](https://user-gold-cdn.xitu.io/2018/2/22/161bb2f266d4512f?w=734&h=348&f=jpeg&s=64031)

- 上图中从左到右依次为tcp/ip四层，tcp/ip五层，osi七层的划分。
- 数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端，就是每个数据都会经过数据的封装和解封装的过程。
- 物理层：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0，
- 数据链路层：单纯的电信号0和1没有任何意义，必须规定电信号多少位一组，每组什么意思，因此数据链路层定义了电信号的分组方式。以太网协议位于该层，在每一帧的head中包含有mac地址，有了mac地址就可以通过广播的方式进行通信。
- 网络层： 广播的方式只能在同一个局域网内进行通信，如果不是同一网络内，就采用路由的方式（向不同广播域／子网分发数据包），mac地址是无法区分的，它只跟厂商有关，因此在网络层有了网络地址的产生。规定网络地址的协议叫ip协议，它定义的地址称之为ip地址，广泛采用的v4版本即ipv4，它规定网络地址由32位2进制表示，范围0.0.0.0-255.255.255.255，一个ip地址通常写成四段十进制数，例：172.19.89.9。
- 传输层： 着重介绍TCP协议。
 1. tcp报文
 
![](https://user-gold-cdn.xitu.io/2018/2/22/161bb46afdfd703b?w=437&h=236&f=jpeg&s=32526)
- 源端口和目标端口:分别占用16位，用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；
- 序号:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；
- 确认号:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；
- 数据偏移:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；
- ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；
- SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；
- FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。
2. 三次握手与四次挥手图解

![](https://user-gold-cdn.xitu.io/2018/2/22/161bb4ca251207b4?w=875&h=976&f=jpeg&s=87111)
- 三次握手
 1. 第一次 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
 2. 第二次：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
 3. 第三次：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
 4. 原因： 第一次客户端发送消息到服务端，服务端接收到回复消息给客户端，也就是当第二次握手客户端接收到消息以后，确保了客户端可以正常发送以及接收消息，第三次握手客户端发确认消息给服务端，确保了服务端可以正常首发消息。彼此都可以收发消息就可以确保通信了。
 - 四次挥手
 1. 第一次：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
 2. 第二次：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
 3. 第三次：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
 4. 第四次：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。
 5. 总结：之所有会有四次，是因为传输过程中可能接收到关闭信号后还有数据未发送完，所以会接着发送，当发送完毕以后会再次挥手。如果没有数据发送了，会有可能变成三次的即第三次的FIN跟第二次的ack合并。
 
### 总结
暂时就总结到这里，以后还会陆续更新。。。。
 
